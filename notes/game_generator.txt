Everything generated by the game generator needs to perfectly correspond to the code that is generated.

E.g., if we say g is a generator, we must ensure g is a generator, if
we say g is a randomly generated element, we must say g is a randomly
generated element







Determining what is global and what can be input by the adversary is
also very important.  E.g., can the adversary change g in sign and
hash?  See email discussion:

If the order of G2 is prime, that's almost sufficient.  g also can't be the identity element.  Do we need to say g is randomly chosen in the SDL or could we make it a generator.  I guess it could be hard to create code that guarantees that it's a generator...  This is important though.  Somehow, we either need the proof to account for the fact that it's randomly generated (which it currently doesn't), or we need the SDL and code to make it a generator.  If we can guarantee that we have a prime-order group, then we can randomly choose g and just check that it's not the identity.

I guess the other option is we could define G2 as the group generated by g.  There probably isn't an easy way to ensure that the message is in that group though...

Make sense?

Hmm, you have a good point about Hash and Sign and globals.  Is g a parameter to Hash and Sign in the SDL?  Is it possible to write the SDL so that it is not?  (g really is a constant of the function.)  Does that solve the problem, or is there any problem at this point, or were you just responding to my email?

Thanks.

Ryan




________________________________________
From: Matthew Pagano [matthew.pagano@gmail.com]
Sent: Monday, July 29, 2013 6:27 PM
To: Gardner, Ryan W.
Subject: Re: Another question

Dr. Gardner,

The SDL tells us that "g" is a randomly chosen element in G2, and that g is a constant.  Is that sufficient knowledge to say "g" should be a global generator?

Ha, I haven't been writing this stuff down :(  But we have all of our emails, so at least not all is lost.  I'll start writing down any pertinent information that isn't retained by email.

I've been using globals b/c EasyCrypt is not like traditional executable code.  Even though "Main" might be the start of the game, not all functions are called from "Main" (e.g., "Hash" and "Sign").  Also, we designed the count variables that each function has to be global so we could keep state outside of the functions themselves.  Same deal for rand_oracle and queried.  Also, can functions return multiple values in EasyCrypt?  If we don't have global variables, we'd need some way of doing that.  If not, does EasyCrypt do structs of some kind?  This could get dicey trying to automate this.  The simple answer is that globals make things easier.  The question is whether they make some things possible (and only possible that way).  I think some of our variables (counts, rand_oracle, queried) make more sense as globals b/c we need to keep state outside of the functions.  Since some functions are not called from Main, that makes it harder to pass things back and forth.  Thoughts?

Matt



On Mon, Jul 29, 2013 at 5:08 PM, Gardner, Ryan W. <Ryan.Gardner@jhuapl.edu<mailto:Ryan.Gardner@jhuapl.edu>> wrote:
Dr. Pagano,

This is kind of tough.  In general, I think I'd like to just remove globals, but we need them for axioms.  In particular, g needs to be a global.  Do we know that g is a generator of some group in the SDL?  Perhaps, we can just make a special case for the generator (and any other essential globals, namely identity elements of groups in BLS)?  I.e., in this case, when you have the generator from the SDL, you just use g_1 or g_T appropriately?  Would that work?

By the way, are you writing this stuff down?  (I'm not, and wouldn't be :), but I know it's a good idea for writing the paper later.)

Otherwise, can we just remove globals and pass things in that need to be passed in.  Is there a problem with that (something we discussed that I'm forgetting)?  (I have some vague memory of a discussion, but I can't remember it precisely or think of any issues.)


Ryan

________________________________________
From: Matthew Pagano [matthew.pagano@gmail.com<mailto:matthew.pagano@gmail.com>]
Sent: Monday, July 29, 2013 2:46 PM
To: Gardner, Ryan W.
Subject: Another question

Hey Ryan,

One more question for you.  This is the line I'm on now:

v = Verify(m, s, pk);

However, the Verify function as written in BLS/bls-full.bv<http://bls-full.bv><http://bls-full.bv> is as follows:

BEGIN :: func:verify
 input := list{pk, M, sig, g}

meaning that we need to include "g" in the call to the Verify function, as well.

So the issue is how to deal with variables that are included in the Verify function that aren't the public key, message, or signature.  My thinking is to make those variables global so that we can just put them into the call to Verify w/o worrying about where they come from or how to get them.

I see from your proofs/bls.ec<http://bls.ec><http://bls.ec> file that you took care of "g" by making it a constant.  That obviously works, but there still might be other variables needed for Verify that aren't are the public key, message, or signature, so we'd still need a way to get those variables.

Does the global option sound correct?

Thanks,
Matt







